use crate::types::ArgError;
use crate::util::*;
use std::env;
use std::io;
use std::path::PathBuf;
use std::process::Command;

const RESTY_COMPAT_VAR: &str = "RESTY_CLI_COMPAT_VERSION";
const RESTY_COMPAT_LATEST: u64 = 30;

const BLOCK_OPEN: &str = "{";
const BLOCK_CLOSE: &str = "}";

#[derive(Debug, Default)]
pub(crate) struct ConfBuilder {
    events: Option<Vec<String>>,
    main: Option<Vec<String>>,
    stream_enabled: bool,
    stream: Option<Vec<String>>,
    http: Option<Vec<String>>,
    lua: Option<Vec<String>>,
    resty_compat_version: Option<u64>,
    modules: Vec<String>,
}

impl ConfBuilder {
    pub(crate) fn new() -> Self {
        Default::default()
    }

    pub(crate) fn events<T>(mut self, t: T) -> Self
    where
        T: IntoIterator<Item = String>,
    {
        self.events = Some(Vec::from_iter(t));
        self
    }

    pub(crate) fn main<T>(mut self, t: T) -> Self
    where
        T: IntoIterator<Item = String>,
    {
        self.main = Some(Vec::from_iter(t));
        self
    }

    pub(crate) fn http<T>(mut self, t: T) -> Self
    where
        T: IntoIterator<Item = String>,
    {
        self.http = Some(Vec::from_iter(t));
        self
    }

    pub(crate) fn stream<T>(mut self, t: T, enabled: bool) -> Self
    where
        T: IntoIterator<Item = String>,
    {
        self.stream = Some(Vec::from_iter(t));
        self.stream_enabled = enabled;
        self
    }

    pub(crate) fn lua<T>(mut self, t: T) -> Self
    where
        T: IntoIterator<Item = String>,
    {
        self.lua = Some(Vec::from_iter(t));
        self
    }

    pub(crate) fn resty_compat_version(mut self, v: u64) -> Self {
        self.resty_compat_version = Some(v);
        self
    }

    pub(crate) fn modules<T>(mut self, t: T) -> Self
    where
        T: IntoIterator<Item = String>,
    {
        self.modules = Vec::from_iter(t);
        self
    }

    pub(crate) fn render<T>(self, buf: &mut T) -> io::Result<()>
    where
        T: io::Write,
    {
        let buf = &mut io::BufWriter::new(buf);

        Conf::from(self).render(buf)
    }
}

impl From<ConfBuilder> for Conf {
    fn from(cb: ConfBuilder) -> Self {
        let ConfBuilder {
            events,
            main,
            stream_enabled,
            stream,
            http,
            lua,
            resty_compat_version,
            modules,
        } = cb;

        Self {
            events: events.unwrap_or_default(),
            main: main.unwrap_or_default(),
            stream: stream.unwrap_or_default(),
            stream_enabled,
            http: http.unwrap_or_default(),
            lua: lua.unwrap_or_default(),
            resty_compat_version: resty_compat_version.unwrap_or_else(get_resty_compat_version),
            modules,
        }
    }
}

struct Conf {
    events: Vec<String>,
    main: Vec<String>,
    stream_enabled: bool,
    stream: Vec<String>,
    http: Vec<String>,
    lua: Vec<String>,
    modules: Vec<String>,
    resty_compat_version: u64,
}

impl Conf {
    fn render<T>(self, buf: &mut T) -> io::Result<()>
    where
        T: io::Write,
    {
        self.render_main(buf)?;
        self.render_events(buf)?;
        self.render_stream(buf)?;
        self.render_http(buf)?;

        Ok(())
    }

    fn render_main<T>(&self, buf: &mut T) -> io::Result<()>
    where
        T: io::Write,
    {
        writeln!(buf, "# generated by rusty-cli")?;
        writeln!(buf, "# resty-cli compat: v0.{}", self.resty_compat_version)?;
        writeln!(buf)?;

        for modname in &self.modules {
            writeln!(buf, "load_module {};", modname)?;
        }

        writeln!(buf, "daemon off;")?;
        writeln!(buf, "master_process off;")?;
        writeln!(buf, "worker_processes 1;")?;
        writeln!(buf, "pid logs/nginx.pid;")?;
        writeln!(buf)?;

        for line in &self.main {
            writeln!(buf, "{}", line)?;
        }

        writeln!(buf)?;

        Ok(())
    }

    fn render_events<T>(&self, buf: &mut T) -> io::Result<()>
    where
        T: io::Write,
    {
        writeln!(buf, "events {}", BLOCK_OPEN)?;

        for line in &self.events {
            writeln!(buf, "    {}", line)?;
        }

        writeln!(buf, "{}", BLOCK_CLOSE)?;
        writeln!(buf)?;

        Ok(())
    }

    fn render_stream<T>(&self, buf: &mut T) -> io::Result<()>
    where
        T: io::Write,
    {
        if self.stream_enabled {
            writeln!(buf, "stream {}", BLOCK_OPEN)?;

            writeln!(buf, "    access_log off;")?;
            writeln!(buf, "    lua_socket_log_errors off;")?;
            writeln!(buf, "    lua_regex_cache_max_entries 40960;")?;

            for line in &self.stream {
                writeln!(buf, "    {}", line)?;
            }

            writeln!(buf, "{}", BLOCK_CLOSE)?;
            writeln!(buf)?;
        }

        Ok(())
    }

    fn render_http<T>(&self, buf: &mut T) -> io::Result<()>
    where
        T: io::Write,
    {
        writeln!(buf, "http {}", BLOCK_OPEN)?;
        writeln!(buf, "    access_log off;")?;
        writeln!(buf, "    lua_socket_log_errors off;")?;
        writeln!(buf, "    lua_regex_cache_max_entries 40960;")?;

        for line in &self.http {
            writeln!(buf, "    {}", line)?;
        }
        writeln!(buf)?;

        self.render_lua(buf)?;

        writeln!(buf, "{}", BLOCK_CLOSE)?;

        Ok(())
    }

    fn render_lua<T>(&self, buf: &mut T) -> io::Result<()>
    where
        T: io::Write,
    {
        const INIT_BY_LUA_OPEN: &str = r##"
    init_by_lua_block {
        ngx.config.is_console = true

        local stdout = io.stdout
        local ngx_null = ngx.null
        local maxn = table.maxn
        local unpack = unpack
        local concat = table.concat

        local expand_table
        function expand_table(src, inplace)
            local n = maxn(src)
            local dst = inplace and src or {}
            for i = 1, n do
                local arg = src[i]
                local typ = type(arg)
                if arg == nil then
                    dst[i] = "nil"

                elseif typ == "boolean" then
                    if arg then
                        dst[i] = "true"
                    else
                        dst[i] = "false"
                    end

                elseif arg == ngx_null then
                    dst[i] = "null"

                elseif typ == "table" then
                    dst[i] = expand_table(arg, false)

                elseif typ ~= "string" then
                    dst[i] = tostring(arg)

                else
                    dst[i] = arg
                end
            end
            return concat(dst)
        end

        local function output(...)
            local args = {...}

            return stdout:write(expand_table(args, true))
        end

        ngx.orig_print = ngx.print
        ngx.print = output

        ngx.orig_say = ngx.say
        ngx.say = function (...)
                local ok, err = output(...)
                if ok then
                    return output("\n")
                end
                return ok, err
            end
        print = ngx.say

        ngx.flush = function (...) return stdout:flush() end
        -- we cannot close stdout here due to a bug in Lua:
        ngx.eof = function (...) return true end
"##;

        const INIT_BY_LUA_CLOSE: &str = "
        ngx.exit = os.exit
    }
";

        const INIT_WORKER_BY_LUA_OPEN: &str = r##"
    init_worker_by_lua_block {
        local exit = os.exit
        local stderr = io.stderr
        local ffi = require "ffi"

        local function handle_err(err)
            if err then
                err = string.gsub(err, "^init_worker_by_lua:%d+: ", "")
                stderr:write("ERROR: ", err, "\n")
            end
            return exit(1)
        end

        local ok, err = pcall(function ()
            if not ngx.config
               or not ngx.config.ngx_lua_version
               or ngx.config.ngx_lua_version < 10009
            then
                error("at least ngx_lua 0.10.9 is required")
            end

            local signal_graceful_exit =
                require("ngx.process").signal_graceful_exit
            if not signal_graceful_exit then
                error("lua-resty-core library is too old; "
                      .. "missing the signal_graceful_exit() function "
                      .. "in ngx.process")
            end
"##;

        const INIT_WORKER_BY_LUA_CLOSE: &str = r##"
            -- print("calling timer.at...")
            local ok, err = ngx.timer.at(0, function ()
                -- io.stderr:write("timer firing")
                local ok, err = xpcall(gen, function (err)
                    -- level 3: we skip this function and the
                    -- error() call itself in our stacktrace
                    local trace = debug.traceback(err, 3)
                    return handle_err(trace)
                end)
                if not ok then
                    return handle_err(err)
                end
                if ffi.abi("win") then
                    return exit(0)
                end
                signal_graceful_exit()
            end)
            if not ok then
                return handle_err(err)
            end
            -- print("timer created")
        end)

        if not ok then
            return handle_err(err)
        end
    }
"##;

        writeln!(buf, "{}", INIT_BY_LUA_OPEN)?;
        writeln!(buf)?;

        if self.resty_compat_version >= 29 {
            writeln!(buf, "        ngx.orig_exit = ngx.exit")?;
            writeln!(buf)?;
        }

        writeln!(buf, "{}", INIT_BY_LUA_CLOSE)?;
        writeln!(buf)?;

        writeln!(buf, "{}", INIT_WORKER_BY_LUA_OPEN)?;
        writeln!(buf)?;

        for line in &self.lua {
            writeln!(buf, "            {}", line)?;
        }
        writeln!(buf)?;

        writeln!(buf, "{}", INIT_WORKER_BY_LUA_CLOSE)?;
        writeln!(buf)?;

        Ok(())
    }
}

#[cfg(default_nginx_path)]
fn find_nginx_bin() -> PathBuf {
    PathBuf::from(env!("NGINX_PATH", "NGINX_PATH is required"))
}

#[cfg(all(test, default_nginx_path))]
#[test]
fn test_default_nginx_path() {
    let got = find_nginx_bin();
    let exp = env!("NGINX_PATH");
    assert_eq!(exp, got.to_str().unwrap());
}

#[cfg(not(default_nginx_path))]
fn find_nginx_bin() -> PathBuf {
    let bin_dir: PathBuf = {
        let bin = env::current_exe().ok().or_else(|| {
            // fallback to argv[0]
            env::args().next().map(PathBuf::from)
        });

        bin.and_then(|exe| exe.parent().map(PathBuf::from))
            .unwrap_or(PathBuf::from("/"))
    };

    // compatibility: resty-cli uses '..' and does not normalize this path
    let nginx = bin_dir.join("../nginx/sbin/nginx");
    if nginx.is_file() {
        return nginx;
    }

    let nginx = bin_dir.join("nginx");
    if nginx.is_file() {
        return nginx;
    }

    PathBuf::from("nginx")
}

pub(crate) fn get_resty_compat_version() -> u64 {
    // TODO: maybe make this a build config item?
    if let Some(value) = env::var_os(RESTY_COMPAT_VAR) {
        let value = &value.to_string_lossy().to_string();

        let value = value.strip_prefix('v').unwrap_or(value);

        let items: Vec<&str> = value.splitn(3, '.').collect();

        let value = if items.len() > 1 { items[1] } else { items[0] };

        value.parse::<u64>().unwrap_or(RESTY_COMPAT_LATEST)
    } else {
        RESTY_COMPAT_LATEST
    }
}

pub(crate) struct Exec {
    pub(crate) prefix: PathBuf,
    pub(crate) runner: Runner,
    pub(crate) bin: Option<PathBuf>,
    pub(crate) label: Option<String>,
}

impl From<Exec> for Command {
    fn from(exec: Exec) -> Self {
        let Exec {
            prefix,
            runner,
            bin,
            label,
        } = exec;

        let prefix = prefix
            .to_str()
            .expect("nginx prefix directory should be a valid string");

        let bin = bin.unwrap_or_else(find_nginx_bin);
        let bin = bin
            .to_str()
            .expect("nginx binary path should be a valid string");

        // resty CLI always adds a trailing slash
        let prefix = format!("{}/", prefix.trim_end_matches('/'));

        let mut nginx_args = vec![];

        if let Some(label) = label {
            nginx_args.push(String::from("-g"));
            nginx_args.push(label);
        }

        nginx_args.push(String::from("-p"));
        nginx_args.push(prefix);
        nginx_args.push(String::from("-c"));
        nginx_args.push(String::from("conf/nginx.conf"));

        let nginx_bin = bin.to_string();
        let bin: String;
        let mut args: Vec<String> = vec![];

        match runner {
            Runner::Default => {
                bin = nginx_bin;
                args.append(&mut nginx_args);
            }
            Runner::RR => {
                bin = String::from("rr");
                args.push(String::from("record"));
                args.push(nginx_bin);
                args.append(&mut nginx_args);
            }
            Runner::Stap(opts) => {
                bin = String::from("stap");
                args = vec![];
                if let Some(opts) = opts {
                    args.append(&mut split_shell_args(&opts));
                }
                args.push("-c".to_owned());
                nginx_args.insert(0, nginx_bin);
                args.push(join_shell_args(&nginx_args));
            }
            Runner::Valgrind(opts) => {
                bin = "valgrind".to_owned();
                args = vec![];
                if let Some(opts) = opts {
                    args.append(&mut split_shell_args(&opts));
                }
                args.push(nginx_bin);
                args.append(&mut nginx_args);
            }
            Runner::Gdb(opts) => {
                bin = String::from("gdb");
                if let Some(opts) = opts {
                    args.append(&mut split_shell_args(&opts));
                }
                args.push("--args".to_owned());
                args.push(nginx_bin);
                args.append(&mut nginx_args);
            }
            Runner::User(runner) => {
                let mut user_args = split_shell_args(&runner);
                bin = user_args.remove(0);
                args.append(&mut user_args);
                args.push(nginx_bin);
                args.append(&mut nginx_args);
            }
        };

        let mut c = Command::new(bin);

        c.args(args);
        c
    }
}

#[derive(Default, Debug, PartialEq, Eq)]
pub(crate) enum Runner {
    #[default]
    Default,
    RR,
    Stap(Option<String>),
    Valgrind(Option<String>),
    Gdb(Option<String>),
    User(String),
}

impl Runner {
    fn arg_name(&self) -> String {
        match self {
            Self::RR => "--rr",
            Self::Stap(_) => "--stap",
            Self::Gdb(_) => "--gdb",
            Self::Valgrind(_) => "--valgrind",
            Self::User(_) => "--user-runner",
            _ => unreachable!(),
        }
        .to_owned()
    }

    fn opt_name(&self) -> String {
        self.arg_name() + "-opts"
    }

    fn same(&self, other: &Runner) -> bool {
        std::mem::discriminant(self) == std::mem::discriminant(other)
    }

    fn takes_opts(&self) -> bool {
        match self {
            Self::Stap(_) => true,
            Self::Gdb(_) => true,
            Self::Valgrind(_) => true,
            Self::User(_) => false,
            Self::RR => false,
            Self::Default => false,
        }
    }

    fn has_opts(&self) -> bool {
        match self {
            Self::Stap(o) | Self::Gdb(o) | Self::Valgrind(o) => o.is_some(),
            Self::User(_) => true,
            Self::RR => false,
            Self::Default => false,
        }
    }

    pub(crate) fn update(&mut self, new: Runner) -> Result<(), ArgError> {
        if let Runner::Default = self {
            *self = new;
            Ok(())
        } else if self.same(&new) {
            // e.g. we already saw --gdb and are now adding opts with --gdb-opts
            if self.takes_opts() && !self.has_opts() && new.has_opts() {
                *self = new;
                Ok(())
            } else {
                Err(ArgError::Duplicate(new.opt_name()))
            }
        } else {
            Err(ArgError::Conflict(self.arg_name(), new.arg_name()))
        }
    }
}

pub(crate) fn version(nginx: Option<&str>) -> Command {
    let mut cmd = if let Some(nginx) = nginx {
        Command::new(nginx)
    } else {
        Command::new(find_nginx_bin())
    };

    cmd.arg("-V");
    cmd
}
