use crate::types::ArgError;
use crate::util::*;
use crate::RESTY_COMPAT_VERSION;
use crate::RUSTY_CLI;
use crate::VERSION;
use std::env;
use std::io;
use std::path::PathBuf;
use std::process::Command;

const BLOCK_OPEN: &str = "{";
const BLOCK_CLOSE: &str = "}";

#[derive(Debug, Default)]
pub(crate) struct ConfBuilder {
    events: Option<Vec<String>>,
    main: Option<Vec<String>>,
    stream_enabled: bool,
    stream: Option<Vec<String>>,
    http: Option<Vec<String>>,
    lua: Option<Vec<String>>,
}

impl ConfBuilder {
    pub(crate) fn new() -> Self {
        Default::default()
    }

    pub(crate) fn events<T>(mut self, t: T) -> Self
    where
        T: IntoIterator<Item = String>,
    {
        self.events = Some(Vec::from_iter(t));
        self
    }

    pub(crate) fn main<T>(mut self, t: T) -> Self
    where
        T: IntoIterator<Item = String>,
    {
        self.main = Some(Vec::from_iter(t));
        self
    }

    pub(crate) fn http<T>(mut self, t: T) -> Self
    where
        T: IntoIterator<Item = String>,
    {
        self.http = Some(Vec::from_iter(t));
        self
    }

    pub(crate) fn stream<T>(mut self, t: T, enabled: bool) -> Self
    where
        T: IntoIterator<Item = String>,
    {
        self.stream = Some(Vec::from_iter(t));
        self.stream_enabled = enabled;
        self
    }

    pub(crate) fn lua<T>(mut self, t: T) -> Self
    where
        T: IntoIterator<Item = String>,
    {
        self.lua = Some(Vec::from_iter(t));
        self
    }

    pub(crate) fn render<T>(self, buf: T) -> io::Result<()>
    where
        T: io::Write,
    {
        Conf::from(self).render(buf)
    }
}

impl From<ConfBuilder> for Conf {
    fn from(cb: ConfBuilder) -> Self {
        let ConfBuilder {
            events,
            main,
            stream_enabled,
            stream,
            http,
            lua,
        } = cb;

        Self {
            events: events.unwrap_or_default(),
            main: main.unwrap_or_default(),
            stream: stream.unwrap_or_default(),
            stream_enabled,
            http: http.unwrap_or_default(),
            lua: lua.unwrap_or_default(),
        }
    }
}

struct Conf {
    events: Vec<String>,
    main: Vec<String>,
    stream_enabled: bool,
    stream: Vec<String>,
    http: Vec<String>,
    lua: Vec<String>,
}

impl Conf {
    fn render<T>(self, mut buf: T) -> io::Result<()>
    where
        T: io::Write,
    {
        {
            let buf = &mut buf;
            self.render_main(buf)?;
            self.render_events(buf)?;
            self.render_stream(buf)?;
            self.render_http(buf)?;
        }

        // always flush before dropping
        buf.flush()?;
        drop(buf);

        Ok(())
    }

    fn render_main<T>(&self, buf: &mut T) -> io::Result<()>
    where
        T: io::Write,
    {
        writeln!(buf, "# generated by {RUSTY_CLI} v{VERSION}")?;
        writeln!(buf, "# resty-cli compat {}", *RESTY_COMPAT_VERSION)?;
        writeln!(buf)?;

        writeln!(buf, "daemon off;")?;
        writeln!(buf, "master_process off;")?;
        writeln!(buf, "worker_processes 1;")?;
        writeln!(buf, "pid logs/nginx.pid;")?;
        writeln!(buf)?;

        for line in &self.main {
            writeln!(buf, "{}", line)?;
        }

        writeln!(buf)?;

        Ok(())
    }

    fn render_events<T>(&self, buf: &mut T) -> io::Result<()>
    where
        T: io::Write,
    {
        writeln!(buf, "events {}", BLOCK_OPEN)?;

        for line in &self.events {
            writeln!(buf, "    {}", line)?;
        }

        writeln!(buf, "{}", BLOCK_CLOSE)?;
        writeln!(buf)?;

        Ok(())
    }

    fn render_stream<T>(&self, buf: &mut T) -> io::Result<()>
    where
        T: io::Write,
    {
        if self.stream_enabled {
            writeln!(buf, "stream {}", BLOCK_OPEN)?;

            writeln!(buf, "    access_log off;")?;
            writeln!(buf, "    lua_socket_log_errors off;")?;
            writeln!(buf, "    lua_regex_cache_max_entries 40960;")?;

            for line in &self.stream {
                writeln!(buf, "    {}", line)?;
            }

            writeln!(buf, "{}", BLOCK_CLOSE)?;
            writeln!(buf)?;
        }

        Ok(())
    }

    fn render_http<T>(&self, buf: &mut T) -> io::Result<()>
    where
        T: io::Write,
    {
        writeln!(buf, "http {}", BLOCK_OPEN)?;
        writeln!(buf, "    access_log off;")?;
        writeln!(buf, "    lua_socket_log_errors off;")?;
        writeln!(buf, "    lua_regex_cache_max_entries 40960;")?;

        for line in &self.http {
            writeln!(buf, "    {}", line)?;
        }
        writeln!(buf)?;

        self.render_lua(buf)?;

        writeln!(buf, "{}", BLOCK_CLOSE)?;

        Ok(())
    }

    fn render_lua<T>(&self, buf: &mut T) -> io::Result<()>
    where
        T: io::Write,
    {
        const INIT_BY_LUA_OPEN: &str = r##"
    init_by_lua_block {
        ngx.config.is_console = true

        local stdout = io.stdout
        local ngx_null = ngx.null
        local maxn = table.maxn
        local unpack = unpack
        local concat = table.concat

        local expand_table
        function expand_table(src, inplace)
            local n = maxn(src)
            local dst = inplace and src or {}
            for i = 1, n do
                local arg = src[i]
                local typ = type(arg)
                if arg == nil then
                    dst[i] = "nil"

                elseif typ == "boolean" then
                    if arg then
                        dst[i] = "true"
                    else
                        dst[i] = "false"
                    end

                elseif arg == ngx_null then
                    dst[i] = "null"

                elseif typ == "table" then
                    dst[i] = expand_table(arg, false)

                elseif typ ~= "string" then
                    dst[i] = tostring(arg)

                else
                    dst[i] = arg
                end
            end
            return concat(dst)
        end

        local function output(...)
            local args = {...}

            return stdout:write(expand_table(args, true))
        end

        ngx.orig_print = ngx.print
        ngx.print = output

        ngx.orig_say = ngx.say
        ngx.say = function (...)
                local ok, err = output(...)
                if ok then
                    return output("\n")
                end
                return ok, err
            end
        print = ngx.say

        ngx.flush = function (...) return stdout:flush() end
        -- we cannot close stdout here due to a bug in Lua:
        ngx.eof = function (...) return true end
"##;

        const INIT_BY_LUA_CLOSE: &str = "
        ngx.exit = os.exit
    }
";

        const INIT_WORKER_BY_LUA_OPEN: &str = r##"
    init_worker_by_lua_block {
        local exit = os.exit
        local stderr = io.stderr
        local ffi = require "ffi"

        local function handle_err(err)
            if err then
                err = string.gsub(err, "^init_worker_by_lua:%d+: ", "")
                stderr:write("ERROR: ", err, "\n")
            end
            return exit(1)
        end

        local ok, err = pcall(function ()
            if not ngx.config
               or not ngx.config.ngx_lua_version
               or ngx.config.ngx_lua_version < 10009
            then
                error("at least ngx_lua 0.10.9 is required")
            end

            local signal_graceful_exit =
                require("ngx.process").signal_graceful_exit
            if not signal_graceful_exit then
                error("lua-resty-core library is too old; "
                      .. "missing the signal_graceful_exit() function "
                      .. "in ngx.process")
            end
"##;

        const INIT_WORKER_BY_LUA_CLOSE: &str = r##"
            -- print("calling timer.at...")
            local ok, err = ngx.timer.at(0, function ()
                -- io.stderr:write("timer firing")
                local ok, err = xpcall(gen, function (err)
                    -- level 3: we skip this function and the
                    -- error() call itself in our stacktrace
                    local trace = debug.traceback(err, 3)
                    return handle_err(trace)
                end)
                if not ok then
                    return handle_err(err)
                end
                if ffi.abi("win") then
                    return exit(0)
                end
                signal_graceful_exit()
            end)
            if not ok then
                return handle_err(err)
            end
            -- print("timer created")
        end)

        if not ok then
            return handle_err(err)
        end
    }
"##;

        writeln!(buf, "{}", INIT_BY_LUA_OPEN)?;
        writeln!(buf)?;

        if *RESTY_COMPAT_VERSION >= (0, 29).into() {
            writeln!(buf, "        ngx.orig_exit = ngx.exit")?;
            writeln!(buf)?;
        }

        writeln!(buf, "{}", INIT_BY_LUA_CLOSE)?;
        writeln!(buf)?;

        writeln!(buf, "{}", INIT_WORKER_BY_LUA_OPEN)?;
        writeln!(buf)?;

        for line in &self.lua {
            writeln!(buf, "            {}", line)?;
        }
        writeln!(buf)?;

        writeln!(buf, "{}", INIT_WORKER_BY_LUA_CLOSE)?;
        writeln!(buf)?;

        Ok(())
    }
}

#[cfg(default_nginx_path)]
fn find_nginx_bin() -> PathBuf {
    PathBuf::from(env!("NGINX_PATH", "NGINX_PATH is required"))
}

#[cfg(all(test, default_nginx_path))]
#[test]
fn test_default_nginx_path() {
    let got = find_nginx_bin();
    let exp = env!("NGINX_PATH");
    assert_eq!(exp, got.to_str().unwrap());
}

#[cfg(not(default_nginx_path))]
fn find_nginx_bin() -> PathBuf {
    let bin_dir: PathBuf = {
        let bin = env::current_exe().ok().or_else(|| {
            // fallback to argv[0]
            env::args().next().map(PathBuf::from)
        });

        bin.and_then(|exe| exe.parent().map(PathBuf::from))
            .unwrap_or(PathBuf::from("/"))
    };

    // compatibility: resty-cli uses '..' and does not normalize this path
    let nginx = bin_dir.join("../nginx/sbin/nginx");
    if nginx.is_file() {
        return nginx;
    }

    let nginx = bin_dir.join("nginx");
    if nginx.is_file() {
        return nginx;
    }

    PathBuf::from("nginx")
}

pub(crate) struct Exec {
    pub(crate) prefix: PathBuf,
    pub(crate) runner: Runner,
    pub(crate) bin: Option<PathBuf>,
    pub(crate) label: Option<String>,
}

pub(crate) trait ArgList<T> {
    fn arg(&mut self, other: T) -> &mut Self;
}

impl<T, I1, I2> ArgList<(I1, I2)> for T
where
    T: ArgList<I1>,
    T: ArgList<I2>,
{
    fn arg(&mut self, other: (I1, I2)) -> &mut Self {
        self.arg(other.0).arg(other.1)
    }
}

impl ArgList<String> for Vec<String> {
    fn arg(&mut self, other: String) -> &mut Self {
        self.push(other);
        self
    }
}

impl ArgList<&String> for Vec<String> {
    fn arg(&mut self, other: &String) -> &mut Self {
        self.arg(other.to_owned())
    }
}

impl ArgList<&str> for Vec<String> {
    fn arg(&mut self, other: &str) -> &mut Self {
        self.arg(other.to_string())
    }
}

impl From<Exec> for Command {
    fn from(exec: Exec) -> Self {
        let Exec {
            prefix,
            runner,
            bin,
            label,
        } = exec;

        let prefix = prefix
            .to_str()
            .expect("nginx prefix directory should be a valid string");

        let nginx = bin.unwrap_or_else(find_nginx_bin);

        let mut args = vec![];

        if let Some(label) = label {
            args.arg(("-g", label));
        }

        // resty CLI always adds a trailing slash
        let prefix = format!("{}/", prefix.trim_end_matches('/'));
        args.arg(("-p", prefix));

        args.arg(("-c", "conf/nginx.conf"));

        runner.into_cmd(nginx, args)
    }
}

#[derive(Default, Debug, PartialEq, Eq)]
pub(crate) enum Runner {
    #[default]
    Default,
    RR,
    Stap(Option<String>),
    Valgrind(Option<String>),
    Gdb(Option<String>),
    User(String),
}

impl Runner {
    fn arg_name(&self) -> String {
        match self {
            Self::RR => "--rr",
            Self::Stap(_) => "--stap",
            Self::Gdb(_) => "--gdb",
            Self::Valgrind(_) => "--valgrind",
            Self::User(_) => "--user-runner",
            _ => unreachable!(),
        }
        .to_owned()
    }

    fn opt_name(&self) -> String {
        self.arg_name() + "-opts"
    }

    fn same(&self, other: &Runner) -> bool {
        std::mem::discriminant(self) == std::mem::discriminant(other)
    }

    fn takes_opts(&self) -> bool {
        match self {
            Self::Stap(_) => true,
            Self::Gdb(_) => true,
            Self::Valgrind(_) => true,
            Self::User(_) => false,
            Self::RR => false,
            Self::Default => false,
        }
    }

    fn has_opts(&self) -> bool {
        match self {
            Self::Stap(o) | Self::Gdb(o) | Self::Valgrind(o) => o.is_some(),
            Self::User(_) => true,
            Self::RR => false,
            Self::Default => false,
        }
    }

    pub(crate) fn update(&mut self, new: Runner) -> Result<(), ArgError> {
        if let Runner::Default = self {
            *self = new;
            Ok(())
        } else if self.same(&new) {
            // e.g. we already saw --gdb and are now adding opts with --gdb-opts
            if self.takes_opts() && !self.has_opts() && new.has_opts() {
                *self = new;
                Ok(())
            } else {
                Err(ArgError::Duplicate(new.opt_name()))
            }
        } else {
            Err(ArgError::Conflict(self.arg_name(), new.arg_name()))
        }
    }

    fn into_cmd(self, nginx: PathBuf, args: Vec<String>) -> Command {
        let mut cmd;
        match self {
            Runner::Default => {
                cmd = Command::new(nginx);
                cmd.args(args);
            }
            Runner::RR => {
                cmd = Command::new("rr");

                cmd.arg("record").arg(nginx).args(args);
            }
            Runner::Stap(opts) => {
                cmd = Command::new("stap");

                if let Some(opts) = opts {
                    cmd.args(opts.split_shell_args());
                }

                cmd.arg("-c");

                let mut args = args;
                args.insert(0, nginx.to_string_lossy().into());

                cmd.arg(args.join_shell_args());
            }
            Runner::Valgrind(opts) => {
                cmd = Command::new("valgrind");

                if let Some(opts) = opts {
                    cmd.args(opts.split_shell_args());
                }

                cmd.arg(nginx).args(args);
            }
            Runner::Gdb(opts) => {
                cmd = Command::new("gdb");

                if let Some(opts) = opts {
                    cmd.args(opts.split_shell_args());
                }

                cmd.arg("--args").arg(nginx).args(args);
            }
            Runner::User(runner) => {
                let mut user_args = runner.split_shell_args();

                cmd = Command::new(user_args.remove(0));

                cmd.args(user_args).arg(nginx).args(args);
            }
        }
        cmd
    }
}

pub(crate) fn version(nginx: Option<PathBuf>) -> Command {
    let mut cmd = if let Some(nginx) = nginx {
        Command::new(nginx)
    } else {
        Command::new(find_nginx_bin())
    };

    cmd.arg("-V");
    cmd
}
