use crate::lua::*;
use crate::nginx::*;
use crate::run::run;
use crate::types::*;
use crate::util::*;
use std::collections::VecDeque;
use std::convert::From;
use std::env;
use std::fmt::Display;
use std::fs;
use std::fs::File;
use std::io::Write as IoWrite;
use std::process;
use std::process::Command;
use thiserror::Error as TE;

pub static VERSION: &str = "0.1.0";

pub static USAGE: &str = r#"Usage: rusty-cli [OPTIONS] [lua-file] [args]...

Arguments:
  [lua-file]

  [args]...


Options:
  -V
          Print version numbers and nginx configurations.
  -I <DIR>
          Add dir to the search paths for Lua libraries.
  -e <PROG>
          Run the inlined Lua code in "prog".
  -l <LIB>
          require lua library "lib"
  -j <OPT>
          LuaJIT option:

          -j dump    Use LuaJIT's jit.dump module to output detailed info of
                     the traces generated by the JIT compiler.

          -j off     Turn off the LuaJIT JIT compiler.

          -j v       Use LuaJIT's jit.v module to output brief info of the
                     traces generated by the JIT compiler. [possible values: v, dump, off]
  -c <NUM>
          Set maximal connection count [default: 64]
      --ns <IP>
          Specify a custom name server (multiple instances are supported).
      --shdict <NAME SIZE>
          Create the specified lua shared dicts in the http configuration block (multiple instances are supported).
      --nginx <PATH>
          Specify the nginx path (this option might be removed in the future).
      --http-conf <CONF>
          Specifies nginx.conf snippet inserted into the http {} configuration block (multiple instances are supported).
      --stream-conf <CONF>
          Disable the stream {} configuration in auto-generated nginx.conf.
      --main-conf <CONF>
          Specifies nginx.conf snippet inserted into the nginx main {} configuration block (multiple instances are supported).
      --http-include <PATH>
          Include the specified file in the nginx http configuration block (multiple instances are supported).
      --main-include <PATH>
          Include the specified file in the nginx main configuration block (multiple instances are supported).
      --valgrind
          Use valgrind to run nginx.
      --valgrind-opts <OPTS>
          Pass extra options to valgrind.
      --errlog-level <LEVEL>
          Set nginx error_log level. [possible values: debug, info, notice, warn, error, crit, alert, emerg]
      --resolve-ipv6
          Make the nginx resolver lookup both IPv4 and IPv6 addresses.
      --user-runner <user-runner>
          Use CMD as user runner for the underlying nginx process.
      --stap
          Use sysetmtap to run the underlying nginx C process.
      --stap-opts <stap-opts>
          Pass extra systemtap command line options.
      --gdb
          Use GDB to run the underlying nginx C process.
      --gdb-opts <gdb-opts>
          Pass extra command-line options to GDB.
      --no-stream
          Specifies nginx.conf snippet inserted into the nginx stream {} configuration block (multiple instances are supported).
      --rr
          Use Mozilla rr to record the execution of the underlying nginx C process.
  -h, --help
          Print help (see more with '--help')"#;

fn resolver(user: &mut UserArgs) -> String {
    let mut ns: Vec<String> = user.nameservers.iter().map(IpAddr::to_string).collect();

    if !user.resolve_ipv6 {
        ns.push("ipv6=off".to_string());
    }

    format!("resolver {};", ns.join(" "))
}

fn env_vars() -> Vec<String> {
    let mut vars: Vec<String> = env::vars()
        .map(|(name, _)| format!("env {};", name))
        .collect();

    vars.sort();
    vars
}

fn http_conf(user: &mut UserArgs) -> Vec<String> {
    let mut conf = vec![];

    conf.push(resolver(user));
    conf.extend(package_path(&user.lua_package_path));
    conf.extend(package_cpath(&user.lua_package_path));

    for shm in user.user_shdicts.iter() {
        conf.push(shm.to_nginx());
    }

    conf.append(&mut user.http_conf);
    conf.extend(
        user.http_include
            .iter()
            .map(|fname| format!("include {};", fname)),
    );

    conf
}

fn stream_conf(user: &mut UserArgs) -> Vec<String> {
    let mut conf = vec![];

    if user.no_stream {
        return conf;
    }

    conf.push(resolver(user));
    conf.extend(package_path(&user.lua_package_path));
    conf.extend(package_cpath(&user.lua_package_path));
    conf.append(&mut user.stream_conf);
    conf
}

fn main_conf(user: &mut UserArgs) -> Vec<String> {
    let mut conf = vec![];
    conf.extend(env_vars());

    conf.push(format!(
        "error_log stderr {};",
        user.errlog_level.to_owned()
    ));

    conf.append(&mut user.main_conf);
    conf.extend(
        user.main_include
            .iter()
            .map(|fname| format!("include {};", fname)),
    );

    conf
}

pub struct NginxExec {
    prefix: String,
    runner: Runner,
    bin: String,
}

impl From<NginxExec> for Command {
    fn from(ngx: NginxExec) -> Self {
        let root = ngx.prefix;

        // resty CLI always adds a trailing slash
        let prefix = format!("{}/", root.trim_end_matches('/'));

        let nginx = ngx.bin;

        let mut nginx_args = vec![
            String::from("-p"),
            prefix,
            String::from("-c"),
            String::from("conf/nginx.conf"),
        ];

        let bin: String;
        let mut args: Vec<String> = vec![];

        match ngx.runner {
            Runner::Default => {
                bin = nginx;
                args.append(&mut nginx_args);
            }
            Runner::RR => {
                bin = String::from("rr");
                args.push(String::from("record"));
                args.push(nginx);
                args.append(&mut nginx_args);
            }
            Runner::Stap(opts) => {
                bin = String::from("stap");
                args = vec![];
                if let Some(opts) = opts {
                    args.append(&mut split_shell_args(&opts));
                }
                args.push("-c".to_owned());
                nginx_args.insert(0, nginx);
                args.push(join_shell_args(
                    nginx_args.iter_mut().map(|s| s.as_str()).collect(),
                ));
            }
            Runner::Valgrind(opts) => {
                bin = "valgrind".to_owned();
                args = vec![];
                if let Some(opts) = opts {
                    args.append(&mut split_shell_args(&opts));
                }
                args.push(nginx);
                args.append(&mut nginx_args);
            }
            Runner::Gdb(opts) => {
                bin = String::from("gdb");
                if let Some(opts) = opts {
                    args.append(&mut split_shell_args(&opts));
                }
                args.push("--args".to_owned());
                args.push(nginx);
                args.append(&mut nginx_args);
            }
            Runner::User(runner) => {
                let mut user_args = split_shell_args(&runner);
                bin = user_args.remove(0);
                args.append(&mut user_args);
                args.push(nginx);
                args.append(&mut nginx_args);
            }
        };

        let mut c = process::Command::new(bin);

        c.args(args);
        c
    }
}

#[derive(Default, Debug)]
pub(crate) enum Runner {
    #[default]
    Default,
    RR,
    Stap(Option<String>),
    Valgrind(Option<String>),
    Gdb(Option<String>),
    User(String),
}

impl Runner {
    fn arg_name(&self) -> String {
        match self {
            Self::RR => "--rr",
            Self::Stap(_) => "--stap",
            Self::Gdb(_) => "--gdb",
            Self::Valgrind(_) => "--valgrind",
            Self::User(_) => "--user-runner",
            _ => unreachable!(),
        }
        .to_owned()
    }

    fn opt_name(&self) -> String {
        self.arg_name() + "-opts"
    }

    fn same(&self, other: &Runner) -> bool {
        std::mem::discriminant(self) == std::mem::discriminant(other)
    }

    fn takes_opts(&self) -> bool {
        match self {
            Self::Stap(_) => true,
            Self::Gdb(_) => true,
            Self::Valgrind(_) => true,
            Self::User(_) => false,
            Self::RR => false,
            Self::Default => false,
        }
    }

    fn has_opts(&self) -> bool {
        match self {
            Self::Stap(o) | Self::Gdb(o) | Self::Valgrind(o) => o.is_some(),
            Self::User(_) => true,
            Self::RR => false,
            Self::Default => false,
        }
    }

    fn update(&mut self, new: Runner) -> Result<(), ArgError> {
        if let Runner::Default = self {
            *self = new;
            Ok(())
        } else if self.same(&new) {
            // e.g. we already saw --gdb and are now adding opts with --gdb-opts
            if self.takes_opts() && !self.has_opts() && new.has_opts() {
                *self = new;
                Ok(())
            } else {
                Err(ArgError::Duplicate(new.opt_name()))
            }
        } else {
            Err(ArgError::Conflict(self.arg_name(), new.arg_name()))
        }
    }
}

#[derive(TE, Debug)]
pub enum ArgError {
    #[error("ERROR: could not find {0} include file '{1}'")]
    MissingInclude(String, String),

    #[error("ERROR: options {0} and {1} cannot be specified at the same time.")]
    Conflict(String, String),

    #[error("ERROR: Invalid {arg} option value: {value}\n  ({err})")]
    InvalidValue {
        arg: String,
        value: String,
        err: String,
    },

    #[error("unknown argument: `{0}`")]
    UnknownArgument(String),

    #[error("option {0} takes an argument but found none.")]
    MissingValue(String),

    #[error("Neither Lua input file nor -e \"\" option specified.")]
    NoLuaInput,

    #[error("duplicate {0} options")]
    Duplicate(String),

    #[error("Lua input file {0} not found.")]
    LuaFileNotFound(String),
}

impl ArgError {
    pub fn exit_code(&self) -> i32 {
        match self {
            // I/O error
            Self::MissingInclude(_, _) => 2,

            // yup, resty-cli returns 25 (ENOTTY) for mutually-exclusive
            // arguments
            //
            // not on purpose though, it's just a side effect of errno
            // having been set from a previous and unrelated error
            Self::Conflict(_, _) => 25,

            Self::UnknownArgument(_) => 1,

            Self::InvalidValue {
                arg: _,
                value: _,
                err: _,
            } => 255,
            Self::MissingValue(_) => 255,

            Self::NoLuaInput => 2,
            Self::LuaFileNotFound(_) => 2,

            Self::Duplicate(_) => 255,
        }
    }
}

pub trait CliOpt {
    fn get_arg(&self, optarg: &mut Option<String>) -> Result<String, ArgError>;

    fn parse_to<T>(&self, value: &mut Option<String>) -> Result<T, ArgError>
    where
        T: std::str::FromStr,
        T::Err: Display;

    fn push_to<T>(&self, items: &mut Vec<T>, value: &mut Option<String>) -> Result<(), ArgError>
    where
        T: std::str::FromStr,
        T::Err: Display,
    {
        Ok(items.push(self.parse_to::<T>(value)?))
    }

    fn is_opt(&self) -> bool;

    fn parse_opt_eq(&self) -> Option<(String, String)>;
}

impl CliOpt for &str {
    fn get_arg(&self, optarg: &mut Option<String>) -> Result<String, ArgError> {
        optarg
            .take()
            .ok_or(ArgError::MissingValue((*self).to_string()))
    }

    fn parse_to<T>(&self, value: &mut Option<String>) -> Result<T, ArgError>
    where
        T: std::str::FromStr,
        T::Err: Display,
    {
        let value = self.get_arg(value)?;

        match value.parse::<T>() {
            Ok(v) => Ok(v),
            Err(e) => Err(ArgError::InvalidValue {
                arg: self.to_string(),
                value,
                err: e.to_string(),
            }),
        }
    }

    fn is_opt(&self) -> bool {
        self.starts_with("--") || self.starts_with('-')
    }

    fn parse_opt_eq(&self) -> Option<(String, String)> {
        if self.is_opt() {
            if let Some((arg, optarg)) = self.split_once('=') {
                return Some((arg.to_string(), optarg.to_string()));
            }
        }
        None
    }
}

impl CliOpt for String {
    fn get_arg(&self, optarg: &mut Option<String>) -> Result<String, ArgError> {
        self.as_str().get_arg(optarg)
    }

    fn parse_to<T>(&self, value: &mut Option<String>) -> Result<T, ArgError>
    where
        T: std::str::FromStr,
        T::Err: Display,
    {
        self.as_str().parse_to::<T>(value)
    }

    fn is_opt(&self) -> bool {
        self.as_str().is_opt()
    }

    fn parse_opt_eq(&self) -> Option<(String, String)> {
        self.as_str().parse_opt_eq()
    }
}

fn include_file(section: &str, fname: String) -> Result<String, ArgError> {
    let path = std::path::Path::new(&fname);
    if !path.is_file() {
        return Err(ArgError::MissingInclude(section.to_string(), fname));
    }

    let path = fs::canonicalize(&fname).map_err(|e| ArgError::InvalidValue {
        arg: format!("--{}-include", section),
        value: fname.clone(),
        err: e.to_string(),
    })?;

    Ok(path.to_str().expect("uh oh").to_string())
}

#[derive(Debug)]
pub enum Action {
    Help,
    Version(Option<String>),
    Main(Box<UserArgs>),
}

impl Action {
    pub fn run(self) -> i32 {
        match self {
            Action::Help => {
                println!("{}", USAGE);
                0
            }

            Action::Version(nginx_bin) => {
                let nginx = find_nginx_bin(nginx_bin);

                let mut c = Command::new(nginx);
                c.arg("-V");

                eprintln!("rusty {}", VERSION);
                run(c)
            }

            Action::Main(mut user) => {
                let prefix = match Prefix::new() {
                    Ok(p) => p,
                    Err(e) => {
                        eprintln!("failed creating prefix directory: {}", e);
                        return 2;
                    }
                };

                if let Some(jit) = &user.jit_cmd {
                    user.inline_lua.insert(0, jit.to_lua());
                }

                let vars = Vars {
                    main_conf: main_conf(&mut user),
                    stream_enabled: !user.no_stream,
                    stream_conf: stream_conf(&mut user),
                    http_conf: http_conf(&mut user),
                    lua_loader: generate_lua_loader(
                        &prefix,
                        &user.lua_file,
                        &user.inline_lua,
                        &user.lua_args,
                        user.arg_0.clone(),
                        user.arg_c,
                    ),
                    events_conf: vec![format!("worker_connections {};", user.worker_connections)],
                };

                let conf_path = prefix.conf.join("nginx.conf");
                let mut fh = std::fs::File::create(conf_path).unwrap();
                fh.write_all(render_config(vars).as_bytes()).unwrap();
                fh.flush().unwrap();
                drop(fh);

                let ngx = NginxExec {
                    bin: find_nginx_bin(user.nginx_bin).to_str().unwrap().to_string(),
                    prefix: prefix.root.to_str().unwrap().to_string(),
                    runner: user.runner,
                };

                run(Command::from(ngx))
            }
        }
    }
}

#[derive(Default, Debug)]
pub struct UserArgs {
    pub(crate) inline_lua: Vec<String>,
    pub(crate) lua_file: Option<String>,
    pub(crate) lua_args: Vec<String>,
    pub(crate) jit_cmd: Option<JitCmd>,

    pub(crate) nginx_bin: Option<String>,
    pub(crate) worker_connections: u32,

    pub(crate) errlog_level: LogLevel,
    pub(crate) lua_package_path: Vec<String>,

    pub(crate) nameservers: Vec<IpAddr>,
    pub(crate) resolve_ipv6: bool,

    pub(crate) http_conf: Vec<String>,
    pub(crate) http_include: Vec<String>,

    pub(crate) main_conf: Vec<String>,
    pub(crate) main_include: Vec<String>,
    pub(crate) user_shdicts: Vec<Shdict>,

    pub(crate) stream_conf: Vec<String>,
    pub(crate) no_stream: bool,

    pub(crate) runner: Runner,

    pub(crate) arg_c: usize,
    pub(crate) arg_0: String,
}

fn default_nameservers() -> Vec<IpAddr> {
    let mut ns = try_parse_resolv_conf();

    if ns.is_empty() {
        // fall back to google dns for compatibility with resty-cli
        ns.push("8.8.8.8".parse().unwrap());
        ns.push("8.8.4.4".parse().unwrap());
    }

    ns
}

pub fn new_parse() -> Result<Action, ArgError> {
    let mut user = UserArgs {
        arg_c: env::args().len(),
        worker_connections: 64,
        ..Default::default()
    };

    let runner = &mut user.runner;

    let mut show_version = false;

    let mut args: VecDeque<String> = env::args().collect();
    user.arg_0 = args.pop_front().expect("empgy ARGV[0]");

    while let Some(arg) = args.pop_front() {
        let mut optarg: Option<String> = None;
        let mut combined_opt_arg = false;
        let mut arg = arg;

        if arg.is_opt() {
            if let Some((a, o)) = arg.parse_opt_eq() {
                arg = a;
                optarg = Some(o);
                combined_opt_arg = true;
            } else {
                optarg = args.pop_front();
            }
        }

        let mut end_of_args = false;

        let optarg = &mut optarg;

        match arg.as_str() {
            "-v" | "-V" | "--version" => {
                show_version = true;
                if user.nginx_bin.is_some() {
                    return Ok(Action::Version(user.nginx_bin));
                }
            }

            "-h" | "--help" => {
                return Ok(Action::Help);
            }

            "--gdb" => runner.update(Runner::Gdb(None))?,

            "--gdb-opts" => {
                let opts = arg.get_arg(optarg)?;
                runner.update(Runner::Gdb(Some(opts)))?;
            }

            "--rr" => runner.update(Runner::RR)?,

            "--stap" => runner.update(Runner::Stap(None))?,

            "--stap-opts" => {
                let opts = arg.get_arg(optarg)?;
                runner.update(Runner::Stap(Some(opts)))?;
            }

            "--user-runner" => {
                let opts = arg.get_arg(optarg)?;
                runner.update(Runner::User(opts))?;
            }

            "--valgrind" => runner.update(Runner::Valgrind(None))?,

            "--valgrind-opts" => {
                let opts = arg.get_arg(optarg)?;
                runner.update(Runner::Valgrind(Some(opts)))?;
            }

            "-c" => {
                user.worker_connections = arg.parse_to(optarg)?;
            }

            "--http-conf" => {
                arg.push_to(&mut user.http_conf, optarg)?;
            }

            "--http-include" => {
                let value = arg.get_arg(optarg)?;
                user.http_include.push(include_file("http", value)?);
            }

            "--main-conf" => {
                arg.push_to(&mut user.main_conf, optarg)?;
            }

            "--main-include" => {
                let value = arg.get_arg(optarg)?;
                user.main_include.push(include_file("main", value)?);
            }

            "--errlog-level" => {
                user.errlog_level = arg.parse_to(optarg)?;
            }

            "--nginx" => {
                let value = arg.get_arg(optarg)?;
                user.nginx_bin = Some(value);

                if show_version {
                    return Ok(Action::Version(user.nginx_bin));
                }
            }

            "--no-stream" => {
                user.no_stream = true;
            }

            "--stream-conf" => {
                arg.push_to(&mut user.stream_conf, optarg)?;
            }

            "--ns" => {
                arg.push_to(&mut user.nameservers, optarg)?;
            }

            "--resolve-ipv6" => {
                user.resolve_ipv6 = true;
            }

            "--shdict" => {
                arg.push_to(&mut user.user_shdicts, optarg)?;
            }

            "-I" => {
                arg.push_to(&mut user.lua_package_path, optarg)?;
            }

            "-j" => {
                user.jit_cmd = Some(arg.parse_to(optarg)?);
            }

            "-l" => {
                let value = arg.get_arg(optarg)?;
                user.inline_lua
                    .push(format!("require({})", value.lua_quote()));
            }

            "-e" => {
                arg.push_to(&mut user.inline_lua, optarg)?;
            }

            "--" => {
                user.lua_file = optarg.take();
                end_of_args = true;
            }

            _ => {
                if arg.is_opt() {
                    return Err(ArgError::UnknownArgument(arg));
                } else {
                    end_of_args = true;
                    user.lua_file = Some(arg.clone());
                }
            }
        }

        if let Some(value) = optarg.take() {
            if combined_opt_arg {
                return Err(ArgError::InvalidValue {
                    arg,
                    value,
                    err: "arg does not take a value".to_string(),
                });
            } else {
                args.push_front(value);
            }
        }

        if end_of_args {
            break;
        }
    }

    user.lua_args.extend(args);

    if show_version {
        return Ok(Action::Version(user.nginx_bin));
    }

    if user.inline_lua.is_empty() && user.lua_file.is_none() && user.jit_cmd.is_none() {
        return Err(ArgError::NoLuaInput);
    }

    if let Some(fname) = &user.lua_file {
        if File::open(fname).is_err() {
            return Err(ArgError::LuaFileNotFound(fname.to_string()));
        }
    }

    if user.nameservers.is_empty() {
        user.nameservers.extend(default_nameservers());
    }

    Ok(Action::Main(Box::new(user)))
}
