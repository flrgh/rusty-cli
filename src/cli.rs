use crate::lua::*;
use crate::nginx;
use crate::nginx::*;
use crate::run::run;
use crate::types::*;
use crate::util::*;
use crate::RESTY_COMPAT_VERSION;
use crate::VERSION;
use std::collections::VecDeque;
use std::convert::From;
use std::env;
use std::fmt::Display;
use std::fs;
use std::fs::File;
use std::path::PathBuf;
use std::process::Command;

const USAGE: &str = r#"
Arguments:
  [lua-file]

  [args]...


Options:
  -V
          Print version numbers and nginx configurations.
  -I <DIR>
          Add dir to the search paths for Lua libraries.
  -e <PROG>
          Run the inlined Lua code in "prog".
  -l <LIB>
          require lua library "lib"
  -j <OPT>
          LuaJIT option:

          -j dump    Use LuaJIT's jit.dump module to output detailed info of
                     the traces generated by the JIT compiler.

          -j off     Turn off the LuaJIT JIT compiler.

          -j v       Use LuaJIT's jit.v module to output brief info of the
                     traces generated by the JIT compiler. [possible values: v, dump, off]
  -c <NUM>
          Set maximal connection count [default: 64]
      --ns <IP>
          Specify a custom name server (multiple instances are supported).
      --shdict <NAME SIZE>
          Create the specified lua shared dicts in the http configuration block (multiple instances are supported).
      --nginx <PATH>
          Specify the nginx path (this option might be removed in the future).
      --http-conf <CONF>
          Specifies nginx.conf snippet inserted into the http {} configuration block (multiple instances are supported).
      --stream-conf <CONF>
          Disable the stream {} configuration in auto-generated nginx.conf.
      --main-conf <CONF>
          Specifies nginx.conf snippet inserted into the nginx main {} configuration block (multiple instances are supported).
      --http-include <PATH>
          Include the specified file in the nginx http configuration block (multiple instances are supported).
      --main-include <PATH>
          Include the specified file in the nginx main configuration block (multiple instances are supported).
      --valgrind
          Use valgrind to run nginx.
      --valgrind-opts <OPTS>
          Pass extra options to valgrind.
      --errlog-level <LEVEL>
          Set nginx error_log level. [possible values: debug, info, notice, warn, error, crit, alert, emerg]
      --resolve-ipv6
          Make the nginx resolver lookup both IPv4 and IPv6 addresses.
      --user-runner <user-runner>
          Use CMD as user runner for the underlying nginx process.
      --stap
          Use sysetmtap to run the underlying nginx C process.
      --stap-opts <stap-opts>
          Pass extra systemtap command line options.
      --gdb
          Use GDB to run the underlying nginx C process.
      --gdb-opts <gdb-opts>
          Pass extra command-line options to GDB.
      --no-stream
          Specifies nginx.conf snippet inserted into the nginx stream {} configuration block (multiple instances are supported).
      --rr
          Use Mozilla rr to record the execution of the underlying nginx C process.
  -h, --help
          Print help (see more with '--help')"#;

fn resolver(user: &mut UserArgs) -> String {
    let mut ns: Vec<String> = user.nameservers.iter().map(IpAddr::to_string).collect();

    if !user.resolve_ipv6 {
        ns.push("ipv6=off".to_string());
    }

    format!("resolver {};", ns.join(" "))
}

fn env_vars() -> Vec<String> {
    let mut vars: Vec<String> = env::vars()
        .map(|(name, _)| format!("env {};", name))
        .collect();

    vars.sort();
    vars
}

fn http_conf(user: &mut UserArgs) -> Vec<String> {
    let mut conf = vec![];

    conf.push(resolver(user));
    conf.extend(package_path(&user.lua_package_path));
    conf.extend(package_cpath(&user.lua_package_path));

    for shm in user.user_shdicts.iter() {
        conf.push(shm.to_nginx());
    }

    conf.append(&mut user.http_conf);
    conf.extend(
        user.http_include
            .iter()
            .map(|fname| format!("include {};", fname)),
    );

    conf
}

fn stream_conf(user: &mut UserArgs) -> Vec<String> {
    let mut conf = vec![];

    if user.no_stream {
        return conf;
    }

    conf.push(resolver(user));
    conf.extend(package_path(&user.lua_package_path));
    conf.extend(package_cpath(&user.lua_package_path));
    conf.append(&mut user.stream_conf);
    conf
}

fn main_conf(user: &mut UserArgs) -> Vec<String> {
    let mut conf = vec![];
    conf.extend(env_vars());

    conf.push(format!(
        "error_log stderr {};",
        user.errlog_level.to_owned()
    ));

    conf.append(&mut user.main_conf);
    conf.extend(
        user.main_include
            .iter()
            .map(|fname| format!("include {};", fname)),
    );

    conf
}

pub(crate) trait CliOpt {
    fn get_arg(&self, optarg: &mut Option<String>) -> Result<String, ArgError>;

    fn parse_to<T>(&self, value: &mut Option<String>) -> Result<T, ArgError>
    where
        T: std::str::FromStr,
        T::Err: Display;

    fn push_to<T>(&self, items: &mut Vec<T>, value: &mut Option<String>) -> Result<(), ArgError>
    where
        T: std::str::FromStr,
        T::Err: Display,
    {
        items.push(self.parse_to::<T>(value)?);
        Ok(())
    }

    fn is_opt(&self) -> bool;

    fn parse_opt_eq(&self) -> Option<(String, String)>;
}

impl<S: AsRef<str>> CliOpt for S {
    fn get_arg(&self, optarg: &mut Option<String>) -> Result<String, ArgError> {
        optarg
            .take()
            .ok_or(ArgError::MissingValue(self.as_ref().to_string()))
    }

    fn parse_to<T>(&self, value: &mut Option<String>) -> Result<T, ArgError>
    where
        T: std::str::FromStr,
        T::Err: Display,
    {
        let value = self.get_arg(value)?;

        match value.parse::<T>() {
            Ok(v) => Ok(v),
            Err(e) => Err(ArgError::InvalidValue {
                arg: self.as_ref().to_string(),
                value,
                err: e.to_string(),
            }),
        }
    }

    fn is_opt(&self) -> bool {
        let s = self.as_ref();
        s.starts_with("--") || s.starts_with('-')
    }

    fn parse_opt_eq(&self) -> Option<(String, String)> {
        if self.is_opt() {
            if let Some((arg, optarg)) = self.as_ref().split_once('=') {
                return Some((arg.to_string(), optarg.to_string()));
            }
        }
        None
    }
}

fn include_file(section: &str, fname: String) -> Result<String, ArgError> {
    let path = std::path::Path::new(&fname);
    if !path.is_file() {
        return Err(ArgError::MissingInclude(section.to_string(), fname));
    }

    let path = fs::canonicalize(&fname).map_err(|e| ArgError::InvalidValue {
        arg: format!("--{}-include", section),
        value: fname.clone(),
        err: e.to_string(),
    })?;

    Ok(path.to_str().expect("uh oh").to_string())
}

fn basename(s: &str) -> &str {
    if s.is_empty() {
        return crate::NAME;
    }

    match s.rsplit_once('/') {
        Some((prefix, base)) => {
            if base.is_empty() || base.ends_with('/') {
                basename(prefix)
            } else {
                base
            }
        }
        _ => s,
    }
}

#[derive(Debug, PartialEq, Eq)]
pub(crate) enum Action {
    Help(String),
    Version(String, Option<String>),
    Main(Box<UserArgs>),
}

impl Action {
    pub(crate) fn run(self) -> i32 {
        match self {
            Action::Help(argv_0) => {
                let argv_0 = basename(&argv_0);
                println!("Usage: {argv_0} [OPTIONS] [lua-file] [args]...");
                println!("{}", USAGE);
                0
            }

            Action::Version(argv_0, nginx_bin) => {
                let cmd = nginx::version(nginx_bin.as_deref());

                let argv_0 = basename(&argv_0);
                match argv_0 {
                    "resty" | "resty-cli" => {
                        let (maj, min) = (*RESTY_COMPAT_VERSION).into();
                        eprintln!("{argv_0} {maj}.{min}");
                    }
                    _ => {
                        eprintln!("{argv_0} {VERSION}");
                    }
                }

                run(cmd)
            }

            Action::Main(mut user) => {
                let prefix = match Prefix::new() {
                    Ok(p) => p,
                    Err(e) => {
                        eprintln!("failed creating prefix directory: {}", e);
                        return 2;
                    }
                };

                if let Some(jit) = &user.jit_cmd {
                    user.inline_lua.insert(0, jit.to_lua());
                }

                let mut label = None;

                if *RESTY_COMPAT_VERSION >= (0, 30).into() {
                    let mut s = String::from("# ");
                    if !user.inline_lua.is_empty() {
                        s.push_str("-e '");
                        s.push_str(user.inline_lua.join("; ").as_ref());
                        s.push('\'');

                        if user.lua_file.is_some() {
                            s.push(' ');
                        }
                    }

                    if let Some(fname) = &user.lua_file {
                        s.push_str(fname);
                    }

                    s = s.replace(['\r', '\n'], "");

                    label = Some(s);
                }

                let lua_loader = match generate_lua_loader(
                    &prefix,
                    &user.lua_file,
                    &user.inline_lua,
                    &user.lua_args,
                    user.arg_0.clone(),
                    user.arg_c,
                ) {
                    Ok(ll) => ll,
                    Err(e) => {
                        eprintln!("failed to generate inline lua: {}", e);
                        return e.raw_os_error().unwrap_or(2);
                    }
                };

                let conf_path = prefix.conf.join("nginx.conf");
                let mut file = match fs::File::create(conf_path) {
                    Ok(file) => file,
                    Err(e) => {
                        eprintln!("failed opening nginx.conf for writing: {}", e);
                        return 2;
                    }
                };

                let events_conf = vec![format!("worker_connections {};", user.worker_connections)];

                let res = nginx::ConfBuilder::new()
                    .main(main_conf(&mut user))
                    .events(events_conf)
                    .stream(stream_conf(&mut user), !user.no_stream)
                    .http(http_conf(&mut user))
                    .lua(lua_loader)
                    .render(&mut file)
                    .and_then(|_| file.flush());

                if let Err(e) = res {
                    eprintln!("failed writing nginx.conf file: {}", e);
                    return 2;
                }

                drop(file);

                let ngx = nginx::Exec {
                    bin: user.nginx_bin.map(PathBuf::from),
                    prefix: prefix.root.clone(),
                    runner: user.runner,
                    label,
                };

                run(Command::from(ngx))
            }
        }
    }
}

#[derive(Default, Debug, PartialEq, Eq)]
pub(crate) struct UserArgs {
    pub(crate) inline_lua: Vec<String>,
    pub(crate) lua_file: Option<String>,
    pub(crate) lua_args: Vec<String>,
    pub(crate) jit_cmd: Option<JitCmd>,

    pub(crate) nginx_bin: Option<String>,
    pub(crate) worker_connections: u32,

    pub(crate) errlog_level: LogLevel,
    pub(crate) lua_package_path: Vec<String>,

    pub(crate) nameservers: Vec<IpAddr>,
    pub(crate) resolve_ipv6: bool,

    pub(crate) http_conf: Vec<String>,
    pub(crate) http_include: Vec<String>,

    pub(crate) main_conf: Vec<String>,
    pub(crate) main_include: Vec<String>,
    pub(crate) user_shdicts: Vec<Shdict>,

    pub(crate) stream_conf: Vec<String>,
    pub(crate) no_stream: bool,

    pub(crate) runner: Runner,

    pub(crate) arg_c: usize,
    pub(crate) arg_0: String,
}

fn discover_system_nameservers() -> Vec<IpAddr> {
    let mut ns = try_parse_resolv_conf();

    // fall back to google dns for compatibility with resty-cli
    if ns.is_empty() {
        ns.push("8.8.8.8".parse().unwrap());
        ns.push("8.8.4.4".parse().unwrap());
    }

    ns
}

impl Action {
    pub(crate) fn try_from<T>(args: T) -> Result<Self, ArgError>
    where
        T: IntoIterator<Item = String>,
    {
        let mut args: VecDeque<String> = args.into_iter().collect();

        let mut user = UserArgs {
            arg_c: args.len(),
            worker_connections: 64,
            ..Default::default()
        };

        let runner = &mut user.runner;

        let mut show_version = false;

        user.arg_0 = args.pop_front().ok_or(ArgError::EmptyArgv0)?;

        while let Some(arg) = args.pop_front() {
            let mut optarg: Option<String> = None;
            let mut combined_opt_arg = false;
            let mut arg = arg;

            if arg.is_opt() {
                if let Some((a, o)) = arg.parse_opt_eq() {
                    arg = a;
                    optarg = Some(o);
                    combined_opt_arg = true;
                } else {
                    optarg = args.pop_front();
                }
            }

            let mut end_of_args = false;

            let optarg = &mut optarg;

            match arg.as_str() {
                "-v" | "-V" | "--version" => {
                    show_version = true;
                    if user.nginx_bin.is_some() {
                        return Ok(Action::Version(user.arg_0, user.nginx_bin));
                    }
                }

                "-h" | "--help" => {
                    return Ok(Action::Help(user.arg_0));
                }

                "--gdb" => runner.update(Runner::Gdb(None))?,

                "--gdb-opts" => {
                    let opts = arg.get_arg(optarg)?;
                    runner.update(Runner::Gdb(Some(opts)))?;
                }

                "--rr" => runner.update(Runner::RR)?,

                "--stap" => runner.update(Runner::Stap(None))?,

                "--stap-opts" => {
                    let opts = arg.get_arg(optarg)?;
                    runner.update(Runner::Stap(Some(opts)))?;
                }

                "--user-runner" => {
                    let opts = arg.get_arg(optarg)?;
                    runner.update(Runner::User(opts))?;
                }

                "--valgrind" => runner.update(Runner::Valgrind(None))?,

                "--valgrind-opts" => {
                    let opts = arg.get_arg(optarg)?;
                    runner.update(Runner::Valgrind(Some(opts)))?;
                }

                "-c" => {
                    user.worker_connections = arg.parse_to(optarg)?;
                }

                "--http-conf" => {
                    arg.push_to(&mut user.http_conf, optarg)?;
                }

                "--http-include" => {
                    let value = arg.get_arg(optarg)?;
                    user.http_include.push(include_file("http", value)?);
                }

                "--main-conf" => {
                    arg.push_to(&mut user.main_conf, optarg)?;
                }

                "--main-include" => {
                    let value = arg.get_arg(optarg)?;
                    user.main_include.push(include_file("main", value)?);
                }

                "--errlog-level" => {
                    user.errlog_level = arg.parse_to(optarg)?;
                }

                "--nginx" => {
                    let value = arg.get_arg(optarg)?;
                    user.nginx_bin = Some(value);

                    if show_version {
                        return Ok(Action::Version(user.arg_0, user.nginx_bin));
                    }
                }

                "--no-stream" => {
                    user.no_stream = true;
                }

                "--stream-conf" => {
                    arg.push_to(&mut user.stream_conf, optarg)?;
                }

                "--ns" => {
                    arg.push_to(&mut user.nameservers, optarg)?;
                }

                "--resolve-ipv6" => {
                    user.resolve_ipv6 = true;
                }

                "--shdict" => {
                    arg.push_to(&mut user.user_shdicts, optarg)?;
                }

                "-I" => {
                    arg.push_to(&mut user.lua_package_path, optarg)?;
                }

                "-j" => {
                    user.jit_cmd = Some(arg.parse_to(optarg)?);
                }

                "-l" => {
                    let value = arg.get_arg(optarg)?;
                    user.inline_lua
                        .push(format!("require({})", value.lua_quote()));
                }

                "-e" => {
                    arg.push_to(&mut user.inline_lua, optarg)?;
                }

                "--" => {
                    user.lua_file = optarg.take();
                    end_of_args = true;
                }

                _ => {
                    if arg.is_opt() {
                        return Err(ArgError::UnknownArgument(arg));
                    } else {
                        end_of_args = true;
                        user.lua_file = Some(arg.clone());
                    }
                }
            }

            if let Some(value) = optarg.take() {
                if combined_opt_arg {
                    return Err(ArgError::InvalidValue {
                        arg,
                        value,
                        err: "arg does not take a value".to_string(),
                    });
                } else {
                    args.push_front(value);
                }
            }

            if end_of_args {
                break;
            }
        }

        user.lua_args.extend(args);

        if show_version {
            return Ok(Action::Version(user.arg_0, user.nginx_bin));
        }

        if user.inline_lua.is_empty() && user.lua_file.is_none() && user.jit_cmd.is_none() {
            return Err(ArgError::NoLuaInput);
        }

        if let Some(fname) = &user.lua_file {
            if File::open(fname).is_err() {
                return Err(ArgError::LuaFileNotFound(fname.to_string()));
            }
        }

        if user.nameservers.is_empty() {
            user.nameservers.extend(discover_system_nameservers());
        }

        Ok(Action::Main(Box::new(user)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    macro_rules! action {
        ( $( $x:expr ),* ) => {
            {
                let v = vec![$($x.to_string(),)*];
                Action::try_from(v)
            }
        };
    }

    macro_rules! svec {
        ( $( $x:expr ),* ) => {
            {
                let v: Vec<String> = vec![$($x.to_string(),)*];
                v
            }
        };
    }

    #[test]
    fn empty_args() {
        assert!(matches!(action!(), Err(ArgError::EmptyArgv0)));
    }

    #[test]
    fn no_lua() {
        assert_eq!(Err(ArgError::NoLuaInput), action!("bin"));
    }

    #[test]
    fn version_action() {
        let exp = Ok(Action::Version("bin".into(), None));

        assert_eq!(exp, action!("bin", "--version"));
        assert_eq!(exp, action!("bin", "-V"));
        assert_eq!(exp, action!("bin", "-v"));
    }

    #[test]
    fn version_action_with_additional_args() {
        let exp = Ok(Action::Version("bin".into(), None));
        assert_eq!(exp, action!("bin", "-v", "--no-stream"));
        assert_eq!(
            exp,
            action!("bin", "-v", "--no-stream", "-e", "ngx.sleep(1)")
        );
    }

    #[test]
    fn version_action_with_nginx_bin() {
        let exp = Ok(Action::Version("bin".into(), Some("my-nginx".to_string())));

        assert_eq!(exp, action!("bin", "--version", "--nginx", "my-nginx"));
        assert_eq!(exp, action!("bin", "-V", "--nginx", "my-nginx"));
        assert_eq!(exp, action!("bin", "-v", "--nginx", "my-nginx"));

        assert_eq!(exp, action!("bin", "--version", "--nginx=my-nginx"));
        assert_eq!(exp, action!("bin", "-V", "--nginx=my-nginx"));
        assert_eq!(exp, action!("bin", "-v", "--nginx=my-nginx"));

        assert_eq!(exp, action!("bin", "--nginx", "my-nginx", "--version"));
        assert_eq!(exp, action!("bin", "--nginx", "my-nginx", "-V"));
        assert_eq!(exp, action!("bin", "--nginx", "my-nginx", "-v"));

        assert_eq!(exp, action!("bin", "--nginx=my-nginx", "--version"));
        assert_eq!(exp, action!("bin", "--nginx=my-nginx", "-V"));
        assert_eq!(exp, action!("bin", "--nginx=my-nginx", "-v"));
    }

    #[test]
    fn help_action() {
        let exp = Ok(Action::Help("bin".into()));
        assert_eq!(exp, action!("bin", "-h"));
        assert_eq!(exp, action!("bin", "--help"));
    }

    #[test]
    fn help_action_extra_args() {
        let exp = Ok(Action::Help("bin".into()));
        assert_eq!(exp, action!("bin", "-h", "--no-stream"));
        assert_eq!(exp, action!("bin", "--help", "--no-stream"));
        assert_eq!(exp, action!("bin", "--no-stream", "-h"));
        assert_eq!(exp, action!("bin", "--no-stream", "--help"));
    }

    #[test]
    fn jit_command_only() {
        // resty-cli doesn't actually complain if you pass in a luajit command
        // with no -e or lua file
        assert!(matches!(action!("bin", "-j", "v"), Ok(Action::Main(_))));
    }

    #[test]
    fn opts_that_require_an_arg() {
        let opts = vec![
            "--stap-opts",
            "--gdb-opts",
            "--user-runner",
            "--valgrind-opts",
            "-c",
            "--http-conf",
            "--http-include",
            "--main-conf",
            "--main-include",
            "--errlog-level",
            "--nginx",
            "--stream-conf",
            "--ns",
            "--shdict",
            "-I",
            "-j",
            "-l",
            "-e",
        ];

        for opt in opts {
            assert!(matches!(
                action!("bin", "-e", "test", opt),
                Err(ArgError::MissingValue(_))
            ));
        }
    }

    #[test]
    fn opts_that_dont_take_an_arg() {
        let opts = vec![
            "--no-stream",
            "--gdb",
            "--rr",
            "--stap",
            "--valgrind",
            "--resolve-ipv6",
        ];

        for opt in opts {
            let with_eq = format!("{}=123", opt);

            assert_eq!(
                Err(ArgError::InvalidValue {
                    arg: opt.to_string(),
                    value: "123".to_string(),
                    err: "arg does not take a value".to_string()
                }),
                action!("bin", with_eq)
            );
        }
    }

    #[test]
    fn happy_paths() {
        #[rustfmt::skip]
        let act = action!(
            "bin",
            "--no-stream",
            "--main-conf", "main-1",
            "-c",          "20",
            "--ns",        "1.2.3.4",
            "--http-conf", "http-1",
            "-l",          "my-require",
            "--ns",        "5.6.7.8",

            "--shdict=my_shdict 1m",

            "-I",          "/my-include-dir",
            "-e",          "expr 1",

            "-l=my-other-require",

            "--http-conf", "http-2",
            "-j",          "off",
            "--nginx",     "my-nginx",
            "-e",          "expr 2",
            "--main-conf", "main-2",

            "-e=expr 3"
        );

        assert!(matches!(act, Ok(Action::Main(_))));

        let Action::Main(args) = act.unwrap() else {
            panic!("oops")
        };

        assert_eq!(20, args.worker_connections);
        assert!(args.no_stream);

        assert_eq!(
            svec!["1.2.3.4", "5.6.7.8"],
            args.nameservers
                .iter()
                .map(String::from)
                .collect::<Vec<String>>()
        );

        assert_eq!(svec!["http-1", "http-2"], args.http_conf);
        assert_eq!(svec!["main-1", "main-2"], args.main_conf);

        assert!(matches!(args.jit_cmd, Some(JitCmd::Off)));

        assert_eq!(Some("my-nginx".to_string()), args.nginx_bin);

        assert_eq!(
            svec![
                "require([=[my-require]=])",
                "expr 1",
                "require([=[my-other-require]=])",
                "expr 2",
                "expr 3"
            ],
            args.inline_lua
        );

        assert_eq!(None, args.lua_file);

        assert!(matches!(args.runner, Runner::Default));

        dbg!(&args);
    }
}
